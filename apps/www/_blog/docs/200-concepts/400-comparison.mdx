---
title: Comparing Wesjet to Other Tools
nav_title: Wesjet vs X
excerpt: Better understand Wesjet and where it fits by using comparisons to tools that you're familiar with.
---

We are regularly asked how Wesjet fits into some given web project. By comparing Wesjet to existing frameworks, we've found it easier to contextualize the role Wesjet plays within a project.

The sections below walk through some common comparisons, categorized by frameworks, content processors, and content sources. In general, Wesjet is more of a complement than a competitor to both frameworks and sources. The most direct comparison is found in content processors.

## Frameworks

Wesjet is not a framework. It is a tool for processing content. However, it can be helpful to think of Wesjet within the context of existing frameworks to better understand how Wesjet can fit into your project.

### Gatsby vs Wesjet

[Gatsby](https://www.gatsbyjs.com/) is a flexible framework that uses a GraphQL layer and rich plugin ecosystem to load content into pages built with React components.

In a way, Wesjet is like taking Gatsby's GraphQL engine and allowing it to be used with other frameworks like Next.js. Aside from its portability among modern frameworks, Wesjet has several advantages over Gatsby's GraphQL solution:

- Gatsby requires that you know GraphQL. Wesjet is just JavaScript.
- Local markdown files cannot be modeled as individual types with Gatsby, while Wesjet provides full control over your structured content schema.
- Wesjet automatically generates TypeScript type definitions for your content.

### Jekyll vs Wesjet

[Jekyll](https://jekyllrb.com/) is a static site generator written in Ruby. It parses local content files and passes them through Liquid templates to generate static HTML pages.

Wesjet can be considered complementary to Jekyll rather than competitive, as Wesjet is a tool for processing content. However, because Jekyll has strong opinions about how content is fed through its system, it likely would not be beneficial to use Wesjet with Jekyll for local content. It would be a better fit for sourcing remote content from headless CMS, though we're not optimizing Wesjet for this usage.

Jekyll is opinionated on how it processes content, and therefore limiting in what you can do with content. Wesjet does not help overcome the limitations of Jekyll. That typically requires moving to a more modern and powerful framework.

### Hugo vs Wesjet

[Hugo](https://gohugo.io/) is a static site generator like Jekyll, but it is written in Go and designed for speed.

Like Jekyll, Wesjet can be considered complementary to Hugo, but not often used together. Typically Wesjet is paired with more modern frameworks like Next.js, while those using Hugo are limited by Hugo's opinions on content processing.

### Next.js vs Wesjet

Wesjet is optimized for Next.js. We envision it becoming the go-to tool for managing content in Next.js projects.

### Remix vs Wesjet

Wesjet is a tool for working with content into JavaScript frameworks. We believe it will become the go-to content solution for Remix. [We're currently considering Remix support](/docs/environments/remix).

### SvelteKit vs Wesjet

Wesjet is a tool for working with content into JavaScript frameworks. We believe it will become the go-to content solution for SvelteKit. [We're currently considering SvelteKit support](/docs/environments/svelte).

### Astro vs Wesjet

Wesjet is a tool for working with content into JavaScript frameworks. We believe it will become the go-to content solution for Astro. [We're currently considering Astro support](/docs/environments/astro).

## Content Processors

An more direct comparison can be found in content-processing tools.

### next-mdx-remote vs Wesjet

[next-mdx-remote](https://github.com/hashicorp/next-mdx-remote) is a set of utilities to help work with MDX in Next.js projects. These utilities are powerful and, before Wesjet, were a great solution for using MDX in Next.js projects.

Where next-mdx-remote stops is that it does not handle loading content from sources, whether local or remote. Wesjet will load content from source files and also supports MDX. Wesjet also automatically generates TypeScript type definitions to ensure the content being processed is in the shape you'd expect, which next-mdx-remote does not handle.

### mdx-bundler vs Wesjet

[mdx-bundler](https://github.com/kentcdodds/mdx-bundler) is a solution for bundling MDX content. It is similar to next-mdx-remote but can handle bundling imports.

Like next-mdx-remote, mdx-bundler is concerned only with the processing content and knows nothing of where the content is sourced. Wesjet provides a full content solution for projects built with modern frameworks.

## Content Sources

With Wesjet, your content can be sourced from anywhere, whether local or remote. We're just getting started and plan to add a number of remote sources in the near future.

Because of this, Wesjet can generally be considered a complement to most headless API-driven solutions today.

### Contentful vs Wesjet

We consider Wesjet to be a complement of Contentful. In fact, we're currently exploring making Contentful the first supported remote source. [Learn more about Contentful integration](/docs/maker/contentful).

### Sanity vs Wesjet

We consider Wesjet to be a complement of Sanity. In fact, we're currently exploring making Sanity the first supported remote source. [Learn more about Sanity integration](/docs/maker/sanity).

### Notion vs Wesjet

We consider Wesjet to be a complement of Notion. In fact, we're currently exploring making Notion the first supported remote source. [Learn more about Notion integration](/docs/maker/notion).
